// <auto-generated>
/*
 * FactSet Estimates
 *
 * With global coverage since 1999, the FactSet Estimates API provides you with comprehensive estimates and statistics on a wide variety of financial statement items as well as industry-specific metrics. The universe is comprised of over 19,000 active companies across 90+ countries with the following types of data included:   - **Consensus** - **Detail** - **Ratings** - **Surprise** - **Segments** - **Actuals** - **Guidance** - **New Estimates and Ratings Reports Endpoints**  For clients seeking  curated and relevant financial data, the FactSet Estimates API now includes Estimates and Ratings Reports endpoints. These powerful endpoints are designed for easy integration and consumption, delivering a wide array of financial metrics, estimates, and critical statistics in a highly accessible format suitable for both mobile and web applications.   Whether you are an analyst, investor, or financial professional, the Estimates and Ratings Reports endpoints offer detailed and actionable financial insights that can support thorough analyses and strategic decision-making processes.   The Estimates and Ratings Reports endpoints are especially valuable for B2B2C  applications, empowering financial services firms, investment companies, and corporate finance teams to:   - **Elevate Client Engagement:** Enrich user experiences in client-facing applications with comprehensive and up-to-date financial metrics.  - **Build Custom Reporting Tools:** Create tailored dashboards and analytics tools that provide deep insights and foster better financial understanding.  By adopting the FactSet Estimates API with its enriched Estimates and Ratings Reports endpoints, businesses can streamline their financial data integration process, improve operational efficiency, and deliver superior financial insights to their clients and end-users.     <p>This API is rate-limited to 10 requests per second and 10 concurrent requests per user.</p>  **Download API Specification**        To programmatically download the FactSet Estimates API Specification file in .yaml format, utilize the link below. You must be authorized for this API to extract the specification. This specification can then be used for Codegen to create your own SDKs. You can also access it by selecting the \"Download Spec\" button beside the version information.      [https://api.factset.com/content/factset-estimates/v2/spec/swagger.yaml](https://api.factset.com/content/factset-estimates/v2/spec/swagger.yaml) 
 *
 * The version of the OpenAPI document: 2.8.1
 * Contact: api@factset.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text.Json;
using FactsetEstimatesClient.Client;
using FactsetEstimatesClient.Model;
using System.Diagnostics.CodeAnalysis;

namespace FactsetEstimatesClient.Api
{
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// This class is registered as transient.
    /// </summary>
    public interface IConsensusApi : IApi
    {
        /// <summary>
        /// The class containing the events
        /// </summary>
        ConsensusApiEvents Events { get; }

        /// <summary>
        /// Retrieves consensus estimates for a requested list of ids and fixed fiscal periods
        /// </summary>
        /// <remarks>
        /// Returns FactSet Estimates consensus data using fixed fiscal dates. For example, if the company&#39;s current unreported year is 12/2020, all data returned by formulas that specify as the period/report basis will be for 12/2005 regardless of what perspective dates (startDate/endDate) are used. The fixed dates are \&quot;locked\&quot; in time and all estimated values are for that explicit date. If you are requesting that the estimated periods can change with the perspective date, please use the rolling-consensus endpoint. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="ids">Security or Entity identifiers. Accepted inputs include FactSet Identifiers, tickers, CUSIP, and SEDOL. &lt;p&gt;&lt;b&gt;Performance Note:&lt;/b&gt; Requests that increase the number of metrics or request long historical data may trigger the 30-second service timeout threshold. To ensure system stability and performance, please keep requests lightweight.&lt;/p&gt; &lt;p&gt;If requesting long historical data, limit the history to &lt;b&gt;10 years per metric per ID&lt;/b&gt;.&lt;/p&gt; </param>
        /// <param name="metrics">Requested metrics. Use the &#x60;/metrics&#x60; endpoint to return a list of available estimate items. **Top 10** most used metrics are **EPS, SALES, DPS, EBITDA,EBIT, PRICE_TGT, CFPS, BPS, NET_INC, and ASSETS**.  For more details, visit [Online Assistant Page #15034](https://oa.apps.factset.com/pages/15034). </param>
        /// <param name="startDate">Start date for point in time of estimates expressed in YYYY-MM-DD format. (optional)</param>
        /// <param name="endDate">End date for point in time of estimates expressed in YYYY-MM-DD format. (optional)</param>
        /// <param name="frequency">Controls the frequency of the data returned.   * **D** &#x3D; Daily   * **W** &#x3D; Weekly, based on the last day of the week of the start date.   * **AM** &#x3D; Monthly, based on the start date (e.g., if the start date is June 16, data is displayed for June 16, May 16, April 16 etc.).         * **AQ** &#x3D; Quarterly, based on the start date.   * **AY** &#x3D; Actual Annual, based on the start date.   (optional, default to AM)</param>
        /// <param name="fiscalPeriodStart">Fiscal period start expressed in absolute date formats. Date that will fall back to most recent completed period during resolution.   * **Fiscal Quarter-end** - YYYY/FQ (e.g., 2019/1F, 2019/2F, 2019/3F, 2019/4F)   * **Fiscal Year-end** - YYYY (e.g. 2019)  (optional)</param>
        /// <param name="fiscalPeriodEnd">Fiscal period start expressed in absolute date formats. Date that will fall back to most recent completed period during resolution.   * **Fiscal Quarter-end** - YYYY/FQ (e.g., 2019/1F, 2019/2F, 2019/3F, 2019/4F)   * **Fiscal Year-end** - YYYY (e.g. 2019)  (optional)</param>
        /// <param name="periodicity">The periodicity for the estimates requested, allowing you to fetch Quarterly, Semi-Annual, Annual, and NTMA/LTMA Estimates.   * **ANN** - Annual   * **QTR** - Quarterly   * **SEMI** - Semi-Annual    * **NTMA** - Next-Twelve-Months - Time-weighted Annual. Estimates use a percentage of annual estimates from two fiscal years to create an estimate based on the 12-month period. Visit [OA 16614](https://my.apps.factset.com/oa/pages/16614) for detail.   * **LTMA** - Last-Twelve-Months - Time-weighted Annual. Estimates use a percentage of annual estimates from two fiscal years to create an estimate based on the 12-month period. Visit [OA 16614](https://my.apps.factset.com/oa/pages/16614) for detail.     (optional, default to ANN)</param>
        /// <param name="currency">Currency code for adjusting the data. Use &#x60;ESTIMATE&#x60; as input value for the values in Estimate Currency. For a list of currency ISO codes, visit [Online Assistant Page #1470](https://oa.apps.factset.com/pages/1470). (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetFixedConsensusApiResponse"/>&gt;</returns>
        Task<IGetFixedConsensusApiResponse> GetFixedConsensusAsync(List<string> ids, List<string> metrics, Option<DateOnly> startDate = default, Option<DateOnly> endDate = default, Option<string> frequency = default, Option<string> fiscalPeriodStart = default, Option<string> fiscalPeriodEnd = default, Option<string> periodicity = default, Option<string> currency = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Retrieves consensus estimates for a requested list of ids and fixed fiscal periods
        /// </summary>
        /// <remarks>
        /// Returns FactSet Estimates consensus data using fixed fiscal dates. For example, if the company&#39;s current unreported year is 12/2020, all data returned by formulas that specify as the period/report basis will be for 12/2005 regardless of what perspective dates (startDate/endDate) are used. The fixed dates are \&quot;locked\&quot; in time and all estimated values are for that explicit date. If you are requesting that the estimated periods can change with the perspective date, please use the rolling-consensus endpoint. 
        /// </remarks>
        /// <param name="ids">Security or Entity identifiers. Accepted inputs include FactSet Identifiers, tickers, CUSIP, and SEDOL. &lt;p&gt;&lt;b&gt;Performance Note:&lt;/b&gt; Requests that increase the number of metrics or request long historical data may trigger the 30-second service timeout threshold. To ensure system stability and performance, please keep requests lightweight.&lt;/p&gt; &lt;p&gt;If requesting long historical data, limit the history to &lt;b&gt;10 years per metric per ID&lt;/b&gt;.&lt;/p&gt; </param>
        /// <param name="metrics">Requested metrics. Use the &#x60;/metrics&#x60; endpoint to return a list of available estimate items. **Top 10** most used metrics are **EPS, SALES, DPS, EBITDA,EBIT, PRICE_TGT, CFPS, BPS, NET_INC, and ASSETS**.  For more details, visit [Online Assistant Page #15034](https://oa.apps.factset.com/pages/15034). </param>
        /// <param name="startDate">Start date for point in time of estimates expressed in YYYY-MM-DD format. (optional)</param>
        /// <param name="endDate">End date for point in time of estimates expressed in YYYY-MM-DD format. (optional)</param>
        /// <param name="frequency">Controls the frequency of the data returned.   * **D** &#x3D; Daily   * **W** &#x3D; Weekly, based on the last day of the week of the start date.   * **AM** &#x3D; Monthly, based on the start date (e.g., if the start date is June 16, data is displayed for June 16, May 16, April 16 etc.).         * **AQ** &#x3D; Quarterly, based on the start date.   * **AY** &#x3D; Actual Annual, based on the start date.   (optional, default to AM)</param>
        /// <param name="fiscalPeriodStart">Fiscal period start expressed in absolute date formats. Date that will fall back to most recent completed period during resolution.   * **Fiscal Quarter-end** - YYYY/FQ (e.g., 2019/1F, 2019/2F, 2019/3F, 2019/4F)   * **Fiscal Year-end** - YYYY (e.g. 2019)  (optional)</param>
        /// <param name="fiscalPeriodEnd">Fiscal period start expressed in absolute date formats. Date that will fall back to most recent completed period during resolution.   * **Fiscal Quarter-end** - YYYY/FQ (e.g., 2019/1F, 2019/2F, 2019/3F, 2019/4F)   * **Fiscal Year-end** - YYYY (e.g. 2019)  (optional)</param>
        /// <param name="periodicity">The periodicity for the estimates requested, allowing you to fetch Quarterly, Semi-Annual, Annual, and NTMA/LTMA Estimates.   * **ANN** - Annual   * **QTR** - Quarterly   * **SEMI** - Semi-Annual    * **NTMA** - Next-Twelve-Months - Time-weighted Annual. Estimates use a percentage of annual estimates from two fiscal years to create an estimate based on the 12-month period. Visit [OA 16614](https://my.apps.factset.com/oa/pages/16614) for detail.   * **LTMA** - Last-Twelve-Months - Time-weighted Annual. Estimates use a percentage of annual estimates from two fiscal years to create an estimate based on the 12-month period. Visit [OA 16614](https://my.apps.factset.com/oa/pages/16614) for detail.     (optional, default to ANN)</param>
        /// <param name="currency">Currency code for adjusting the data. Use &#x60;ESTIMATE&#x60; as input value for the values in Estimate Currency. For a list of currency ISO codes, visit [Online Assistant Page #1470](https://oa.apps.factset.com/pages/1470). (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetFixedConsensusApiResponse"/>?&gt;</returns>
        Task<IGetFixedConsensusApiResponse?> GetFixedConsensusOrDefaultAsync(List<string> ids, List<string> metrics, Option<DateOnly> startDate = default, Option<DateOnly> endDate = default, Option<string> frequency = default, Option<string> fiscalPeriodStart = default, Option<string> fiscalPeriodEnd = default, Option<string> periodicity = default, Option<string> currency = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// FactSet consensus estimates for fixed fiscal periods
        /// </summary>
        /// <remarks>
        /// Returns FactSet Estimates consensus data using fixed fiscal dates. For example, if the company&#39;s current unreported year is 12/2020, all data returned by formulas that specify as the period/report basis will be for 12/2005 regardless of what perspective dates (startDate/endDate) are used. The fixed dates are \&quot;locked\&quot; in time and all estimated values are for that explicit date. If you are requesting that the estimated periods can change with the perspective date, please use the rolling-consensus endpoint. 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="fixedConsensusRequest">Request object for Estimate Data Items.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetFixedConsensusForListApiResponse"/>&gt;</returns>
        Task<IGetFixedConsensusForListApiResponse> GetFixedConsensusForListAsync(FixedConsensusRequest fixedConsensusRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// FactSet consensus estimates for fixed fiscal periods
        /// </summary>
        /// <remarks>
        /// Returns FactSet Estimates consensus data using fixed fiscal dates. For example, if the company&#39;s current unreported year is 12/2020, all data returned by formulas that specify as the period/report basis will be for 12/2005 regardless of what perspective dates (startDate/endDate) are used. The fixed dates are \&quot;locked\&quot; in time and all estimated values are for that explicit date. If you are requesting that the estimated periods can change with the perspective date, please use the rolling-consensus endpoint. 
        /// </remarks>
        /// <param name="fixedConsensusRequest">Request object for Estimate Data Items.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetFixedConsensusForListApiResponse"/>?&gt;</returns>
        Task<IGetFixedConsensusForListApiResponse?> GetFixedConsensusForListOrDefaultAsync(FixedConsensusRequest fixedConsensusRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Retrieves consensus estimates for a requested list of ids and rolling fiscal periods.
        /// </summary>
        /// <remarks>
        /// Returns FactSet Estimates consensus data using rolling fiscal dates. &lt;p&gt;The rolling behavior causes fiscal year to automatically roll from one year to the next as the historical perspective date changes. The fiscal period rolls forward as of each period end. This endpoint is optimized to allow the request to simply include a relative fiscal period (e.g. use relativeFiscalStart integer 1 and periodicity ANN for next unreported fiscal year end), and then see what the consensus thought the \&quot;next fiscal year\&quot; estimates were through time as you \&quot;roll\&quot; back your perspective dates. This differs from locking down an absolute estimate period such as explicitly stating Fiscal Year 2019. This can be done in the fixed-consensus endpoint.&lt;/p&gt; 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="ids">Security or Entity identifiers. Accepted inputs include FactSet Identifiers, tickers, CUSIP, and SEDOL. &lt;p&gt;&lt;b&gt;Performance Note:&lt;/b&gt; Requests that increase the number of metrics or request long historical data may trigger the 30-second service timeout threshold. To ensure system stability and performance, please keep requests lightweight.&lt;/p&gt; &lt;p&gt;If requesting long historical data, limit the history to &lt;b&gt;10 years per metric per ID&lt;/b&gt;.&lt;/p&gt; </param>
        /// <param name="metrics">Requested metrics. Use the &#x60;/metrics&#x60; endpoint to return a list of available estimate items. **Top 10** most used metrics are **EPS, SALES, DPS, EBITDA,EBIT, PRICE_TGT, CFPS, BPS, NET_INC, and ASSETS**.  For more details, visit [Online Assistant Page #15034](https://oa.apps.factset.com/pages/15034). </param>
        /// <param name="startDate">Start date for point in time of estimates expressed in YYYY-MM-DD format. (optional)</param>
        /// <param name="endDate">End date for point in time of estimates expressed in YYYY-MM-DD format. (optional)</param>
        /// <param name="frequency">Controls the frequency of the data returned.   * **D** &#x3D; Daily   * **W** &#x3D; Weekly, based on the last day of the week of the start date.   * **AM** &#x3D; Monthly, based on the start date (e.g., if the start date is June 16, data is displayed for June 16, May 16, April 16 etc.).         * **AQ** &#x3D; Quarterly, based on the start date.   * **AY** &#x3D; Actual Annual, based on the start date.   (optional, default to AM)</param>
        /// <param name="relativeFiscalStart">Relative fiscal period, expressed as an integer, used to filter results. This is combined with the periodicity parameter to specify a relative estimate period. For example, set to 1 and periodicity to ANN to ask for relative Fiscal Year 1 (FY1). (optional)</param>
        /// <param name="relativeFiscalEnd">Relative fiscal period, expressed as an integer, used to filter results. This is combined with the periodicity parameter to specify a relative estimate period. For example, set to 2 and periodicity to ANN to ask for relative Fiscal Year 1 (FY2). (optional)</param>
        /// <param name="periodicity">The periodicity for the estimates requested, allowing you to fetch Quarterly, Semi-Annual, Annual, and NTMA/LTMA Estimates.   * **ANN** - Annual   * **QTR** - Quarterly   * **SEMI** - Semi-Annual    * **NTMA** - Next-Twelve-Months - Time-weighted Annual. Estimates use a percentage of annual estimates from two fiscal years to create an estimate based on the 12-month period. Visit [OA 16614](https://my.apps.factset.com/oa/pages/16614) for detail.   * **LTMA** - Last-Twelve-Months - Time-weighted Annual. Estimates use a percentage of annual estimates from two fiscal years to create an estimate based on the 12-month period. Visit [OA 16614](https://my.apps.factset.com/oa/pages/16614) for detail.     (optional, default to ANN)</param>
        /// <param name="currency">Currency code for adjusting the data. Use &#x60;ESTIMATE&#x60; as input value for the values in Estimate Currency. For a list of currency ISO codes, visit [Online Assistant Page #1470](https://oa.apps.factset.com/pages/1470). (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetRollingConsensusApiResponse"/>&gt;</returns>
        Task<IGetRollingConsensusApiResponse> GetRollingConsensusAsync(List<string> ids, List<string> metrics, Option<DateOnly> startDate = default, Option<DateOnly> endDate = default, Option<string> frequency = default, Option<int> relativeFiscalStart = default, Option<int> relativeFiscalEnd = default, Option<string> periodicity = default, Option<string> currency = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Retrieves consensus estimates for a requested list of ids and rolling fiscal periods.
        /// </summary>
        /// <remarks>
        /// Returns FactSet Estimates consensus data using rolling fiscal dates. &lt;p&gt;The rolling behavior causes fiscal year to automatically roll from one year to the next as the historical perspective date changes. The fiscal period rolls forward as of each period end. This endpoint is optimized to allow the request to simply include a relative fiscal period (e.g. use relativeFiscalStart integer 1 and periodicity ANN for next unreported fiscal year end), and then see what the consensus thought the \&quot;next fiscal year\&quot; estimates were through time as you \&quot;roll\&quot; back your perspective dates. This differs from locking down an absolute estimate period such as explicitly stating Fiscal Year 2019. This can be done in the fixed-consensus endpoint.&lt;/p&gt; 
        /// </remarks>
        /// <param name="ids">Security or Entity identifiers. Accepted inputs include FactSet Identifiers, tickers, CUSIP, and SEDOL. &lt;p&gt;&lt;b&gt;Performance Note:&lt;/b&gt; Requests that increase the number of metrics or request long historical data may trigger the 30-second service timeout threshold. To ensure system stability and performance, please keep requests lightweight.&lt;/p&gt; &lt;p&gt;If requesting long historical data, limit the history to &lt;b&gt;10 years per metric per ID&lt;/b&gt;.&lt;/p&gt; </param>
        /// <param name="metrics">Requested metrics. Use the &#x60;/metrics&#x60; endpoint to return a list of available estimate items. **Top 10** most used metrics are **EPS, SALES, DPS, EBITDA,EBIT, PRICE_TGT, CFPS, BPS, NET_INC, and ASSETS**.  For more details, visit [Online Assistant Page #15034](https://oa.apps.factset.com/pages/15034). </param>
        /// <param name="startDate">Start date for point in time of estimates expressed in YYYY-MM-DD format. (optional)</param>
        /// <param name="endDate">End date for point in time of estimates expressed in YYYY-MM-DD format. (optional)</param>
        /// <param name="frequency">Controls the frequency of the data returned.   * **D** &#x3D; Daily   * **W** &#x3D; Weekly, based on the last day of the week of the start date.   * **AM** &#x3D; Monthly, based on the start date (e.g., if the start date is June 16, data is displayed for June 16, May 16, April 16 etc.).         * **AQ** &#x3D; Quarterly, based on the start date.   * **AY** &#x3D; Actual Annual, based on the start date.   (optional, default to AM)</param>
        /// <param name="relativeFiscalStart">Relative fiscal period, expressed as an integer, used to filter results. This is combined with the periodicity parameter to specify a relative estimate period. For example, set to 1 and periodicity to ANN to ask for relative Fiscal Year 1 (FY1). (optional)</param>
        /// <param name="relativeFiscalEnd">Relative fiscal period, expressed as an integer, used to filter results. This is combined with the periodicity parameter to specify a relative estimate period. For example, set to 2 and periodicity to ANN to ask for relative Fiscal Year 1 (FY2). (optional)</param>
        /// <param name="periodicity">The periodicity for the estimates requested, allowing you to fetch Quarterly, Semi-Annual, Annual, and NTMA/LTMA Estimates.   * **ANN** - Annual   * **QTR** - Quarterly   * **SEMI** - Semi-Annual    * **NTMA** - Next-Twelve-Months - Time-weighted Annual. Estimates use a percentage of annual estimates from two fiscal years to create an estimate based on the 12-month period. Visit [OA 16614](https://my.apps.factset.com/oa/pages/16614) for detail.   * **LTMA** - Last-Twelve-Months - Time-weighted Annual. Estimates use a percentage of annual estimates from two fiscal years to create an estimate based on the 12-month period. Visit [OA 16614](https://my.apps.factset.com/oa/pages/16614) for detail.     (optional, default to ANN)</param>
        /// <param name="currency">Currency code for adjusting the data. Use &#x60;ESTIMATE&#x60; as input value for the values in Estimate Currency. For a list of currency ISO codes, visit [Online Assistant Page #1470](https://oa.apps.factset.com/pages/1470). (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetRollingConsensusApiResponse"/>?&gt;</returns>
        Task<IGetRollingConsensusApiResponse?> GetRollingConsensusOrDefaultAsync(List<string> ids, List<string> metrics, Option<DateOnly> startDate = default, Option<DateOnly> endDate = default, Option<string> frequency = default, Option<int> relativeFiscalStart = default, Option<int> relativeFiscalEnd = default, Option<string> periodicity = default, Option<string> currency = default, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Retrieves consensus estimates for a requested list of ids and rolling fiscal periods
        /// </summary>
        /// <remarks>
        /// Returns FactSet Estimates consensus data using rolling fiscal dates. &lt;p&gt;The rolling behavior causes fiscal year to automatically roll from one year to the next as the historical perspective date changes. The fiscal period rolls forward as of each period end. This endpoint is optimized to allow the request to simply include a relative fiscal period (e.g. use relativeFiscalStart integer 1 and periodicity ANN for next unreported fiscal year end), and then see what the consensus thought the \&quot;next fiscal year\&quot; estimates were through time as you \&quot;roll\&quot; back your perspective dates. This differs from locking down an absolute estimate period such as explicitly stating Fiscal Year 2019. This can be done in the fixed-consensus endpoint.&lt;/p&gt; 
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="rollingConsensusRequest">Request object for Rolling Conensus estimates.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetRollingConsensusForListApiResponse"/>&gt;</returns>
        Task<IGetRollingConsensusForListApiResponse> GetRollingConsensusForListAsync(RollingConsensusRequest rollingConsensusRequest, System.Threading.CancellationToken cancellationToken = default);

        /// <summary>
        /// Retrieves consensus estimates for a requested list of ids and rolling fiscal periods
        /// </summary>
        /// <remarks>
        /// Returns FactSet Estimates consensus data using rolling fiscal dates. &lt;p&gt;The rolling behavior causes fiscal year to automatically roll from one year to the next as the historical perspective date changes. The fiscal period rolls forward as of each period end. This endpoint is optimized to allow the request to simply include a relative fiscal period (e.g. use relativeFiscalStart integer 1 and periodicity ANN for next unreported fiscal year end), and then see what the consensus thought the \&quot;next fiscal year\&quot; estimates were through time as you \&quot;roll\&quot; back your perspective dates. This differs from locking down an absolute estimate period such as explicitly stating Fiscal Year 2019. This can be done in the fixed-consensus endpoint.&lt;/p&gt; 
        /// </remarks>
        /// <param name="rollingConsensusRequest">Request object for Rolling Conensus estimates.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetRollingConsensusForListApiResponse"/>?&gt;</returns>
        Task<IGetRollingConsensusForListApiResponse?> GetRollingConsensusForListOrDefaultAsync(RollingConsensusRequest rollingConsensusRequest, System.Threading.CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// The <see cref="IGetFixedConsensusApiResponse"/>
    /// </summary>
    public interface IGetFixedConsensusApiResponse : FactsetEstimatesClient.Client.IApiResponse, IOk<FactsetEstimatesClient.Model.ConsensusResponse?>, IBadRequest<FactsetEstimatesClient.Model.ErrorResponse?>, IUnauthorized<FactsetEstimatesClient.Model.ErrorResponse?>, IForbidden<FactsetEstimatesClient.Model.ErrorResponse?>, IUnsupportedMediaType<FactsetEstimatesClient.Model.ErrorResponse?>, IInternalServerError<FactsetEstimatesClient.Model.ErrorResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 415 UnsupportedMediaType
        /// </summary>
        /// <returns></returns>
        bool IsUnsupportedMediaType { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IGetFixedConsensusForListApiResponse"/>
    /// </summary>
    public interface IGetFixedConsensusForListApiResponse : FactsetEstimatesClient.Client.IApiResponse, IOk<FactsetEstimatesClient.Model.ConsensusResponse?>, IBadRequest<FactsetEstimatesClient.Model.ErrorResponse?>, IUnauthorized<FactsetEstimatesClient.Model.ErrorResponse?>, IForbidden<FactsetEstimatesClient.Model.ErrorResponse?>, IUnsupportedMediaType<FactsetEstimatesClient.Model.ErrorResponse?>, IInternalServerError<FactsetEstimatesClient.Model.ErrorResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 415 UnsupportedMediaType
        /// </summary>
        /// <returns></returns>
        bool IsUnsupportedMediaType { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IGetRollingConsensusApiResponse"/>
    /// </summary>
    public interface IGetRollingConsensusApiResponse : FactsetEstimatesClient.Client.IApiResponse, IOk<FactsetEstimatesClient.Model.ConsensusResponse?>, IBadRequest<FactsetEstimatesClient.Model.ErrorResponse?>, IUnauthorized<FactsetEstimatesClient.Model.ErrorResponse?>, IForbidden<FactsetEstimatesClient.Model.ErrorResponse?>, IUnsupportedMediaType<FactsetEstimatesClient.Model.ErrorResponse?>, IInternalServerError<FactsetEstimatesClient.Model.ErrorResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 415 UnsupportedMediaType
        /// </summary>
        /// <returns></returns>
        bool IsUnsupportedMediaType { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// The <see cref="IGetRollingConsensusForListApiResponse"/>
    /// </summary>
    public interface IGetRollingConsensusForListApiResponse : FactsetEstimatesClient.Client.IApiResponse, IOk<FactsetEstimatesClient.Model.ConsensusResponse?>, IBadRequest<FactsetEstimatesClient.Model.ErrorResponse?>, IUnauthorized<FactsetEstimatesClient.Model.ErrorResponse?>, IForbidden<FactsetEstimatesClient.Model.ErrorResponse?>, IUnsupportedMediaType<FactsetEstimatesClient.Model.ErrorResponse?>, IInternalServerError<FactsetEstimatesClient.Model.ErrorResponse?>
    {
        /// <summary>
        /// Returns true if the response is 200 Ok
        /// </summary>
        /// <returns></returns>
        bool IsOk { get; }

        /// <summary>
        /// Returns true if the response is 400 BadRequest
        /// </summary>
        /// <returns></returns>
        bool IsBadRequest { get; }

        /// <summary>
        /// Returns true if the response is 401 Unauthorized
        /// </summary>
        /// <returns></returns>
        bool IsUnauthorized { get; }

        /// <summary>
        /// Returns true if the response is 403 Forbidden
        /// </summary>
        /// <returns></returns>
        bool IsForbidden { get; }

        /// <summary>
        /// Returns true if the response is 415 UnsupportedMediaType
        /// </summary>
        /// <returns></returns>
        bool IsUnsupportedMediaType { get; }

        /// <summary>
        /// Returns true if the response is 500 InternalServerError
        /// </summary>
        /// <returns></returns>
        bool IsInternalServerError { get; }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public class ConsensusApiEvents
    {
        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetFixedConsensus;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetFixedConsensus;

        internal void ExecuteOnGetFixedConsensus(ConsensusApi.GetFixedConsensusApiResponse apiResponse)
        {
            OnGetFixedConsensus?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetFixedConsensus(Exception exception)
        {
            OnErrorGetFixedConsensus?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetFixedConsensusForList;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetFixedConsensusForList;

        internal void ExecuteOnGetFixedConsensusForList(ConsensusApi.GetFixedConsensusForListApiResponse apiResponse)
        {
            OnGetFixedConsensusForList?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetFixedConsensusForList(Exception exception)
        {
            OnErrorGetFixedConsensusForList?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetRollingConsensus;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetRollingConsensus;

        internal void ExecuteOnGetRollingConsensus(ConsensusApi.GetRollingConsensusApiResponse apiResponse)
        {
            OnGetRollingConsensus?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetRollingConsensus(Exception exception)
        {
            OnErrorGetRollingConsensus?.Invoke(this, new ExceptionEventArgs(exception));
        }

        /// <summary>
        /// The event raised after the server response
        /// </summary>
        public event EventHandler<ApiResponseEventArgs>? OnGetRollingConsensusForList;

        /// <summary>
        /// The event raised after an error querying the server
        /// </summary>
        public event EventHandler<ExceptionEventArgs>? OnErrorGetRollingConsensusForList;

        internal void ExecuteOnGetRollingConsensusForList(ConsensusApi.GetRollingConsensusForListApiResponse apiResponse)
        {
            OnGetRollingConsensusForList?.Invoke(this, new ApiResponseEventArgs(apiResponse));
        }

        internal void ExecuteOnErrorGetRollingConsensusForList(Exception exception)
        {
            OnErrorGetRollingConsensusForList?.Invoke(this, new ExceptionEventArgs(exception));
        }
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    public sealed partial class ConsensusApi : IConsensusApi
    {
        private JsonSerializerOptions _jsonSerializerOptions;

        /// <summary>
        /// The logger factory
        /// </summary>
        public ILoggerFactory LoggerFactory { get; }

        /// <summary>
        /// The logger
        /// </summary>
        public ILogger<ConsensusApi> Logger { get; }

        /// <summary>
        /// The HttpClient
        /// </summary>
        public HttpClient HttpClient { get; }

        /// <summary>
        /// The class containing the events
        /// </summary>
        public ConsensusApiEvents Events { get; }

        /// <summary>
        /// A token provider of type <see cref="BasicTokenProvider"/>
        /// </summary>
        public TokenProvider<BasicToken> BasicTokenProvider { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref="ConsensusApi"/> class.
        /// </summary>
        /// <returns></returns>
        public ConsensusApi(ILogger<ConsensusApi> logger, ILoggerFactory loggerFactory, HttpClient httpClient, JsonSerializerOptionsProvider jsonSerializerOptionsProvider, ConsensusApiEvents consensusApiEvents,
            TokenProvider<BasicToken> basicTokenProvider)
        {
            _jsonSerializerOptions = jsonSerializerOptionsProvider.Options;
            LoggerFactory = loggerFactory;
            Logger = LoggerFactory.CreateLogger<ConsensusApi>();
            HttpClient = httpClient;
            Events = consensusApiEvents;
            BasicTokenProvider = basicTokenProvider;
        }

        partial void FormatGetFixedConsensus(List<string> ids, List<string> metrics, ref Option<DateOnly> startDate, ref Option<DateOnly> endDate, ref Option<string> frequency, ref Option<string> fiscalPeriodStart, ref Option<string> fiscalPeriodEnd, ref Option<string> periodicity, ref Option<string> currency);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="ids"></param>
        /// <param name="metrics"></param>
        /// <param name="frequency"></param>
        /// <param name="fiscalPeriodStart"></param>
        /// <param name="fiscalPeriodEnd"></param>
        /// <param name="periodicity"></param>
        /// <param name="currency"></param>
        /// <returns></returns>
        private void ValidateGetFixedConsensus(List<string> ids, List<string> metrics, Option<string> frequency, Option<string> fiscalPeriodStart, Option<string> fiscalPeriodEnd, Option<string> periodicity, Option<string> currency)
        {
            if (ids == null)
                throw new ArgumentNullException(nameof(ids));

            if (metrics == null)
                throw new ArgumentNullException(nameof(metrics));

            if (frequency.IsSet && frequency.Value == null)
                throw new ArgumentNullException(nameof(frequency));

            if (fiscalPeriodStart.IsSet && fiscalPeriodStart.Value == null)
                throw new ArgumentNullException(nameof(fiscalPeriodStart));

            if (fiscalPeriodEnd.IsSet && fiscalPeriodEnd.Value == null)
                throw new ArgumentNullException(nameof(fiscalPeriodEnd));

            if (periodicity.IsSet && periodicity.Value == null)
                throw new ArgumentNullException(nameof(periodicity));

            if (currency.IsSet && currency.Value == null)
                throw new ArgumentNullException(nameof(currency));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="ids"></param>
        /// <param name="metrics"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="frequency"></param>
        /// <param name="fiscalPeriodStart"></param>
        /// <param name="fiscalPeriodEnd"></param>
        /// <param name="periodicity"></param>
        /// <param name="currency"></param>
        private void AfterGetFixedConsensusDefaultImplementation(IGetFixedConsensusApiResponse apiResponseLocalVar, List<string> ids, List<string> metrics, Option<DateOnly> startDate, Option<DateOnly> endDate, Option<string> frequency, Option<string> fiscalPeriodStart, Option<string> fiscalPeriodEnd, Option<string> periodicity, Option<string> currency)
        {
            bool suppressDefaultLog = false;
            AfterGetFixedConsensus(ref suppressDefaultLog, apiResponseLocalVar, ids, metrics, startDate, endDate, frequency, fiscalPeriodStart, fiscalPeriodEnd, periodicity, currency);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="ids"></param>
        /// <param name="metrics"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="frequency"></param>
        /// <param name="fiscalPeriodStart"></param>
        /// <param name="fiscalPeriodEnd"></param>
        /// <param name="periodicity"></param>
        /// <param name="currency"></param>
        partial void AfterGetFixedConsensus(ref bool suppressDefaultLog, IGetFixedConsensusApiResponse apiResponseLocalVar, List<string> ids, List<string> metrics, Option<DateOnly> startDate, Option<DateOnly> endDate, Option<string> frequency, Option<string> fiscalPeriodStart, Option<string> fiscalPeriodEnd, Option<string> periodicity, Option<string> currency);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="ids"></param>
        /// <param name="metrics"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="frequency"></param>
        /// <param name="fiscalPeriodStart"></param>
        /// <param name="fiscalPeriodEnd"></param>
        /// <param name="periodicity"></param>
        /// <param name="currency"></param>
        private void OnErrorGetFixedConsensusDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, List<string> ids, List<string> metrics, Option<DateOnly> startDate, Option<DateOnly> endDate, Option<string> frequency, Option<string> fiscalPeriodStart, Option<string> fiscalPeriodEnd, Option<string> periodicity, Option<string> currency)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetFixedConsensus(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, ids, metrics, startDate, endDate, frequency, fiscalPeriodStart, fiscalPeriodEnd, periodicity, currency);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="ids"></param>
        /// <param name="metrics"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="frequency"></param>
        /// <param name="fiscalPeriodStart"></param>
        /// <param name="fiscalPeriodEnd"></param>
        /// <param name="periodicity"></param>
        /// <param name="currency"></param>
        partial void OnErrorGetFixedConsensus(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, List<string> ids, List<string> metrics, Option<DateOnly> startDate, Option<DateOnly> endDate, Option<string> frequency, Option<string> fiscalPeriodStart, Option<string> fiscalPeriodEnd, Option<string> periodicity, Option<string> currency);

        /// <summary>
        /// Retrieves consensus estimates for a requested list of ids and fixed fiscal periods Returns FactSet Estimates consensus data using fixed fiscal dates. For example, if the company&#39;s current unreported year is 12/2020, all data returned by formulas that specify as the period/report basis will be for 12/2005 regardless of what perspective dates (startDate/endDate) are used. The fixed dates are \&quot;locked\&quot; in time and all estimated values are for that explicit date. If you are requesting that the estimated periods can change with the perspective date, please use the rolling-consensus endpoint. 
        /// </summary>
        /// <param name="ids">Security or Entity identifiers. Accepted inputs include FactSet Identifiers, tickers, CUSIP, and SEDOL. &lt;p&gt;&lt;b&gt;Performance Note:&lt;/b&gt; Requests that increase the number of metrics or request long historical data may trigger the 30-second service timeout threshold. To ensure system stability and performance, please keep requests lightweight.&lt;/p&gt; &lt;p&gt;If requesting long historical data, limit the history to &lt;b&gt;10 years per metric per ID&lt;/b&gt;.&lt;/p&gt; </param>
        /// <param name="metrics">Requested metrics. Use the &#x60;/metrics&#x60; endpoint to return a list of available estimate items. **Top 10** most used metrics are **EPS, SALES, DPS, EBITDA,EBIT, PRICE_TGT, CFPS, BPS, NET_INC, and ASSETS**.  For more details, visit [Online Assistant Page #15034](https://oa.apps.factset.com/pages/15034). </param>
        /// <param name="startDate">Start date for point in time of estimates expressed in YYYY-MM-DD format. (optional)</param>
        /// <param name="endDate">End date for point in time of estimates expressed in YYYY-MM-DD format. (optional)</param>
        /// <param name="frequency">Controls the frequency of the data returned.   * **D** &#x3D; Daily   * **W** &#x3D; Weekly, based on the last day of the week of the start date.   * **AM** &#x3D; Monthly, based on the start date (e.g., if the start date is June 16, data is displayed for June 16, May 16, April 16 etc.).         * **AQ** &#x3D; Quarterly, based on the start date.   * **AY** &#x3D; Actual Annual, based on the start date.   (optional, default to AM)</param>
        /// <param name="fiscalPeriodStart">Fiscal period start expressed in absolute date formats. Date that will fall back to most recent completed period during resolution.   * **Fiscal Quarter-end** - YYYY/FQ (e.g., 2019/1F, 2019/2F, 2019/3F, 2019/4F)   * **Fiscal Year-end** - YYYY (e.g. 2019)  (optional)</param>
        /// <param name="fiscalPeriodEnd">Fiscal period start expressed in absolute date formats. Date that will fall back to most recent completed period during resolution.   * **Fiscal Quarter-end** - YYYY/FQ (e.g., 2019/1F, 2019/2F, 2019/3F, 2019/4F)   * **Fiscal Year-end** - YYYY (e.g. 2019)  (optional)</param>
        /// <param name="periodicity">The periodicity for the estimates requested, allowing you to fetch Quarterly, Semi-Annual, Annual, and NTMA/LTMA Estimates.   * **ANN** - Annual   * **QTR** - Quarterly   * **SEMI** - Semi-Annual    * **NTMA** - Next-Twelve-Months - Time-weighted Annual. Estimates use a percentage of annual estimates from two fiscal years to create an estimate based on the 12-month period. Visit [OA 16614](https://my.apps.factset.com/oa/pages/16614) for detail.   * **LTMA** - Last-Twelve-Months - Time-weighted Annual. Estimates use a percentage of annual estimates from two fiscal years to create an estimate based on the 12-month period. Visit [OA 16614](https://my.apps.factset.com/oa/pages/16614) for detail.     (optional, default to ANN)</param>
        /// <param name="currency">Currency code for adjusting the data. Use &#x60;ESTIMATE&#x60; as input value for the values in Estimate Currency. For a list of currency ISO codes, visit [Online Assistant Page #1470](https://oa.apps.factset.com/pages/1470). (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetFixedConsensusApiResponse"/>&gt;</returns>
        public async Task<IGetFixedConsensusApiResponse?> GetFixedConsensusOrDefaultAsync(List<string> ids, List<string> metrics, Option<DateOnly> startDate = default, Option<DateOnly> endDate = default, Option<string> frequency = default, Option<string> fiscalPeriodStart = default, Option<string> fiscalPeriodEnd = default, Option<string> periodicity = default, Option<string> currency = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetFixedConsensusAsync(ids, metrics, startDate, endDate, frequency, fiscalPeriodStart, fiscalPeriodEnd, periodicity, currency, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Retrieves consensus estimates for a requested list of ids and fixed fiscal periods Returns FactSet Estimates consensus data using fixed fiscal dates. For example, if the company&#39;s current unreported year is 12/2020, all data returned by formulas that specify as the period/report basis will be for 12/2005 regardless of what perspective dates (startDate/endDate) are used. The fixed dates are \&quot;locked\&quot; in time and all estimated values are for that explicit date. If you are requesting that the estimated periods can change with the perspective date, please use the rolling-consensus endpoint. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="ids">Security or Entity identifiers. Accepted inputs include FactSet Identifiers, tickers, CUSIP, and SEDOL. &lt;p&gt;&lt;b&gt;Performance Note:&lt;/b&gt; Requests that increase the number of metrics or request long historical data may trigger the 30-second service timeout threshold. To ensure system stability and performance, please keep requests lightweight.&lt;/p&gt; &lt;p&gt;If requesting long historical data, limit the history to &lt;b&gt;10 years per metric per ID&lt;/b&gt;.&lt;/p&gt; </param>
        /// <param name="metrics">Requested metrics. Use the &#x60;/metrics&#x60; endpoint to return a list of available estimate items. **Top 10** most used metrics are **EPS, SALES, DPS, EBITDA,EBIT, PRICE_TGT, CFPS, BPS, NET_INC, and ASSETS**.  For more details, visit [Online Assistant Page #15034](https://oa.apps.factset.com/pages/15034). </param>
        /// <param name="startDate">Start date for point in time of estimates expressed in YYYY-MM-DD format. (optional)</param>
        /// <param name="endDate">End date for point in time of estimates expressed in YYYY-MM-DD format. (optional)</param>
        /// <param name="frequency">Controls the frequency of the data returned.   * **D** &#x3D; Daily   * **W** &#x3D; Weekly, based on the last day of the week of the start date.   * **AM** &#x3D; Monthly, based on the start date (e.g., if the start date is June 16, data is displayed for June 16, May 16, April 16 etc.).         * **AQ** &#x3D; Quarterly, based on the start date.   * **AY** &#x3D; Actual Annual, based on the start date.   (optional, default to AM)</param>
        /// <param name="fiscalPeriodStart">Fiscal period start expressed in absolute date formats. Date that will fall back to most recent completed period during resolution.   * **Fiscal Quarter-end** - YYYY/FQ (e.g., 2019/1F, 2019/2F, 2019/3F, 2019/4F)   * **Fiscal Year-end** - YYYY (e.g. 2019)  (optional)</param>
        /// <param name="fiscalPeriodEnd">Fiscal period start expressed in absolute date formats. Date that will fall back to most recent completed period during resolution.   * **Fiscal Quarter-end** - YYYY/FQ (e.g., 2019/1F, 2019/2F, 2019/3F, 2019/4F)   * **Fiscal Year-end** - YYYY (e.g. 2019)  (optional)</param>
        /// <param name="periodicity">The periodicity for the estimates requested, allowing you to fetch Quarterly, Semi-Annual, Annual, and NTMA/LTMA Estimates.   * **ANN** - Annual   * **QTR** - Quarterly   * **SEMI** - Semi-Annual    * **NTMA** - Next-Twelve-Months - Time-weighted Annual. Estimates use a percentage of annual estimates from two fiscal years to create an estimate based on the 12-month period. Visit [OA 16614](https://my.apps.factset.com/oa/pages/16614) for detail.   * **LTMA** - Last-Twelve-Months - Time-weighted Annual. Estimates use a percentage of annual estimates from two fiscal years to create an estimate based on the 12-month period. Visit [OA 16614](https://my.apps.factset.com/oa/pages/16614) for detail.     (optional, default to ANN)</param>
        /// <param name="currency">Currency code for adjusting the data. Use &#x60;ESTIMATE&#x60; as input value for the values in Estimate Currency. For a list of currency ISO codes, visit [Online Assistant Page #1470](https://oa.apps.factset.com/pages/1470). (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetFixedConsensusApiResponse"/>&gt;</returns>
        public async Task<IGetFixedConsensusApiResponse> GetFixedConsensusAsync(List<string> ids, List<string> metrics, Option<DateOnly> startDate = default, Option<DateOnly> endDate = default, Option<string> frequency = default, Option<string> fiscalPeriodStart = default, Option<string> fiscalPeriodEnd = default, Option<string> periodicity = default, Option<string> currency = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetFixedConsensus(ids, metrics, frequency, fiscalPeriodStart, fiscalPeriodEnd, periodicity, currency);

                FormatGetFixedConsensus(ids, metrics, ref startDate, ref endDate, ref frequency, ref fiscalPeriodStart, ref fiscalPeriodEnd, ref periodicity, ref currency);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/factset-estimates/v2/fixed-consensus"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/factset-estimates/v2/fixed-consensus");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["ids"] = ClientUtils.ParameterToString(ids);
                    parseQueryStringLocalVar["metrics"] = ClientUtils.ParameterToString(metrics);

                    if (startDate.IsSet)
                        parseQueryStringLocalVar["startDate"] = ClientUtils.ParameterToString(startDate.Value);

                    if (endDate.IsSet)
                        parseQueryStringLocalVar["endDate"] = ClientUtils.ParameterToString(endDate.Value);

                    if (frequency.IsSet)
                        parseQueryStringLocalVar["frequency"] = ClientUtils.ParameterToString(frequency.Value);

                    if (fiscalPeriodStart.IsSet)
                        parseQueryStringLocalVar["fiscalPeriodStart"] = ClientUtils.ParameterToString(fiscalPeriodStart.Value);

                    if (fiscalPeriodEnd.IsSet)
                        parseQueryStringLocalVar["fiscalPeriodEnd"] = ClientUtils.ParameterToString(fiscalPeriodEnd.Value);

                    if (periodicity.IsSet)
                        parseQueryStringLocalVar["periodicity"] = ClientUtils.ParameterToString(periodicity.Value);

                    if (currency.IsSet)
                        parseQueryStringLocalVar["currency"] = ClientUtils.ParameterToString(currency.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BasicToken basicTokenLocalVar1 = (BasicToken) await BasicTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(basicTokenLocalVar1);

                    basicTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetFixedConsensusApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetFixedConsensusApiResponse>();
                        GetFixedConsensusApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/factset-estimates/v2/fixed-consensus", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetFixedConsensusDefaultImplementation(apiResponseLocalVar, ids, metrics, startDate, endDate, frequency, fiscalPeriodStart, fiscalPeriodEnd, periodicity, currency);

                        Events.ExecuteOnGetFixedConsensus(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetFixedConsensusDefaultImplementation(e, "/factset-estimates/v2/fixed-consensus", uriBuilderLocalVar.Path, ids, metrics, startDate, endDate, frequency, fiscalPeriodStart, fiscalPeriodEnd, periodicity, currency);
                Events.ExecuteOnErrorGetFixedConsensus(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetFixedConsensusApiResponse"/>
        /// </summary>
        public partial class GetFixedConsensusApiResponse : FactsetEstimatesClient.Client.ApiResponse, IGetFixedConsensusApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetFixedConsensusApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetFixedConsensusApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetFixedConsensusApiResponse(ILogger<GetFixedConsensusApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetFixedConsensusApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetFixedConsensusApiResponse(ILogger<GetFixedConsensusApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public FactsetEstimatesClient.Model.ConsensusResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<FactsetEstimatesClient.Model.ConsensusResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out FactsetEstimatesClient.Model.ConsensusResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public FactsetEstimatesClient.Model.ErrorResponse? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<FactsetEstimatesClient.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out FactsetEstimatesClient.Model.ErrorResponse? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public FactsetEstimatesClient.Model.ErrorResponse? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<FactsetEstimatesClient.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out FactsetEstimatesClient.Model.ErrorResponse? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public FactsetEstimatesClient.Model.ErrorResponse? Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<FactsetEstimatesClient.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out FactsetEstimatesClient.Model.ErrorResponse? result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 415 UnsupportedMediaType
            /// </summary>
            /// <returns></returns>
            public bool IsUnsupportedMediaType => 415 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 415 UnsupportedMediaType
            /// </summary>
            /// <returns></returns>
            public FactsetEstimatesClient.Model.ErrorResponse? UnsupportedMediaType()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnsupportedMediaType
                    ? System.Text.Json.JsonSerializer.Deserialize<FactsetEstimatesClient.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 415 UnsupportedMediaType and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnsupportedMediaType([NotNullWhen(true)]out FactsetEstimatesClient.Model.ErrorResponse? result)
            {
                result = null;

                try
                {
                    result = UnsupportedMediaType();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)415);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public FactsetEstimatesClient.Model.ErrorResponse? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<FactsetEstimatesClient.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out FactsetEstimatesClient.Model.ErrorResponse? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetFixedConsensusForList(FixedConsensusRequest fixedConsensusRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="fixedConsensusRequest"></param>
        /// <returns></returns>
        private void ValidateGetFixedConsensusForList(FixedConsensusRequest fixedConsensusRequest)
        {
            if (fixedConsensusRequest == null)
                throw new ArgumentNullException(nameof(fixedConsensusRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="fixedConsensusRequest"></param>
        private void AfterGetFixedConsensusForListDefaultImplementation(IGetFixedConsensusForListApiResponse apiResponseLocalVar, FixedConsensusRequest fixedConsensusRequest)
        {
            bool suppressDefaultLog = false;
            AfterGetFixedConsensusForList(ref suppressDefaultLog, apiResponseLocalVar, fixedConsensusRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="fixedConsensusRequest"></param>
        partial void AfterGetFixedConsensusForList(ref bool suppressDefaultLog, IGetFixedConsensusForListApiResponse apiResponseLocalVar, FixedConsensusRequest fixedConsensusRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="fixedConsensusRequest"></param>
        private void OnErrorGetFixedConsensusForListDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, FixedConsensusRequest fixedConsensusRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetFixedConsensusForList(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, fixedConsensusRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="fixedConsensusRequest"></param>
        partial void OnErrorGetFixedConsensusForList(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, FixedConsensusRequest fixedConsensusRequest);

        /// <summary>
        /// FactSet consensus estimates for fixed fiscal periods Returns FactSet Estimates consensus data using fixed fiscal dates. For example, if the company&#39;s current unreported year is 12/2020, all data returned by formulas that specify as the period/report basis will be for 12/2005 regardless of what perspective dates (startDate/endDate) are used. The fixed dates are \&quot;locked\&quot; in time and all estimated values are for that explicit date. If you are requesting that the estimated periods can change with the perspective date, please use the rolling-consensus endpoint. 
        /// </summary>
        /// <param name="fixedConsensusRequest">Request object for Estimate Data Items.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetFixedConsensusForListApiResponse"/>&gt;</returns>
        public async Task<IGetFixedConsensusForListApiResponse?> GetFixedConsensusForListOrDefaultAsync(FixedConsensusRequest fixedConsensusRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetFixedConsensusForListAsync(fixedConsensusRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// FactSet consensus estimates for fixed fiscal periods Returns FactSet Estimates consensus data using fixed fiscal dates. For example, if the company&#39;s current unreported year is 12/2020, all data returned by formulas that specify as the period/report basis will be for 12/2005 regardless of what perspective dates (startDate/endDate) are used. The fixed dates are \&quot;locked\&quot; in time and all estimated values are for that explicit date. If you are requesting that the estimated periods can change with the perspective date, please use the rolling-consensus endpoint. 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="fixedConsensusRequest">Request object for Estimate Data Items.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetFixedConsensusForListApiResponse"/>&gt;</returns>
        public async Task<IGetFixedConsensusForListApiResponse> GetFixedConsensusForListAsync(FixedConsensusRequest fixedConsensusRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetFixedConsensusForList(fixedConsensusRequest);

                FormatGetFixedConsensusForList(fixedConsensusRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/factset-estimates/v2/fixed-consensus"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/factset-estimates/v2/fixed-consensus");

                    httpRequestMessageLocalVar.Content = (fixedConsensusRequest as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(fixedConsensusRequest, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BasicToken basicTokenLocalVar1 = (BasicToken) await BasicTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(basicTokenLocalVar1);

                    basicTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetFixedConsensusForListApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetFixedConsensusForListApiResponse>();
                        GetFixedConsensusForListApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/factset-estimates/v2/fixed-consensus", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetFixedConsensusForListDefaultImplementation(apiResponseLocalVar, fixedConsensusRequest);

                        Events.ExecuteOnGetFixedConsensusForList(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetFixedConsensusForListDefaultImplementation(e, "/factset-estimates/v2/fixed-consensus", uriBuilderLocalVar.Path, fixedConsensusRequest);
                Events.ExecuteOnErrorGetFixedConsensusForList(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetFixedConsensusForListApiResponse"/>
        /// </summary>
        public partial class GetFixedConsensusForListApiResponse : FactsetEstimatesClient.Client.ApiResponse, IGetFixedConsensusForListApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetFixedConsensusForListApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetFixedConsensusForListApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetFixedConsensusForListApiResponse(ILogger<GetFixedConsensusForListApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetFixedConsensusForListApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetFixedConsensusForListApiResponse(ILogger<GetFixedConsensusForListApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public FactsetEstimatesClient.Model.ConsensusResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<FactsetEstimatesClient.Model.ConsensusResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out FactsetEstimatesClient.Model.ConsensusResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public FactsetEstimatesClient.Model.ErrorResponse? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<FactsetEstimatesClient.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out FactsetEstimatesClient.Model.ErrorResponse? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public FactsetEstimatesClient.Model.ErrorResponse? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<FactsetEstimatesClient.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out FactsetEstimatesClient.Model.ErrorResponse? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public FactsetEstimatesClient.Model.ErrorResponse? Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<FactsetEstimatesClient.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out FactsetEstimatesClient.Model.ErrorResponse? result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 415 UnsupportedMediaType
            /// </summary>
            /// <returns></returns>
            public bool IsUnsupportedMediaType => 415 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 415 UnsupportedMediaType
            /// </summary>
            /// <returns></returns>
            public FactsetEstimatesClient.Model.ErrorResponse? UnsupportedMediaType()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnsupportedMediaType
                    ? System.Text.Json.JsonSerializer.Deserialize<FactsetEstimatesClient.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 415 UnsupportedMediaType and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnsupportedMediaType([NotNullWhen(true)]out FactsetEstimatesClient.Model.ErrorResponse? result)
            {
                result = null;

                try
                {
                    result = UnsupportedMediaType();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)415);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public FactsetEstimatesClient.Model.ErrorResponse? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<FactsetEstimatesClient.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out FactsetEstimatesClient.Model.ErrorResponse? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetRollingConsensus(List<string> ids, List<string> metrics, ref Option<DateOnly> startDate, ref Option<DateOnly> endDate, ref Option<string> frequency, ref Option<int> relativeFiscalStart, ref Option<int> relativeFiscalEnd, ref Option<string> periodicity, ref Option<string> currency);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="ids"></param>
        /// <param name="metrics"></param>
        /// <param name="frequency"></param>
        /// <param name="periodicity"></param>
        /// <param name="currency"></param>
        /// <returns></returns>
        private void ValidateGetRollingConsensus(List<string> ids, List<string> metrics, Option<string> frequency, Option<string> periodicity, Option<string> currency)
        {
            if (ids == null)
                throw new ArgumentNullException(nameof(ids));

            if (metrics == null)
                throw new ArgumentNullException(nameof(metrics));

            if (frequency.IsSet && frequency.Value == null)
                throw new ArgumentNullException(nameof(frequency));

            if (periodicity.IsSet && periodicity.Value == null)
                throw new ArgumentNullException(nameof(periodicity));

            if (currency.IsSet && currency.Value == null)
                throw new ArgumentNullException(nameof(currency));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="ids"></param>
        /// <param name="metrics"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="frequency"></param>
        /// <param name="relativeFiscalStart"></param>
        /// <param name="relativeFiscalEnd"></param>
        /// <param name="periodicity"></param>
        /// <param name="currency"></param>
        private void AfterGetRollingConsensusDefaultImplementation(IGetRollingConsensusApiResponse apiResponseLocalVar, List<string> ids, List<string> metrics, Option<DateOnly> startDate, Option<DateOnly> endDate, Option<string> frequency, Option<int> relativeFiscalStart, Option<int> relativeFiscalEnd, Option<string> periodicity, Option<string> currency)
        {
            bool suppressDefaultLog = false;
            AfterGetRollingConsensus(ref suppressDefaultLog, apiResponseLocalVar, ids, metrics, startDate, endDate, frequency, relativeFiscalStart, relativeFiscalEnd, periodicity, currency);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="ids"></param>
        /// <param name="metrics"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="frequency"></param>
        /// <param name="relativeFiscalStart"></param>
        /// <param name="relativeFiscalEnd"></param>
        /// <param name="periodicity"></param>
        /// <param name="currency"></param>
        partial void AfterGetRollingConsensus(ref bool suppressDefaultLog, IGetRollingConsensusApiResponse apiResponseLocalVar, List<string> ids, List<string> metrics, Option<DateOnly> startDate, Option<DateOnly> endDate, Option<string> frequency, Option<int> relativeFiscalStart, Option<int> relativeFiscalEnd, Option<string> periodicity, Option<string> currency);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="ids"></param>
        /// <param name="metrics"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="frequency"></param>
        /// <param name="relativeFiscalStart"></param>
        /// <param name="relativeFiscalEnd"></param>
        /// <param name="periodicity"></param>
        /// <param name="currency"></param>
        private void OnErrorGetRollingConsensusDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, List<string> ids, List<string> metrics, Option<DateOnly> startDate, Option<DateOnly> endDate, Option<string> frequency, Option<int> relativeFiscalStart, Option<int> relativeFiscalEnd, Option<string> periodicity, Option<string> currency)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetRollingConsensus(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, ids, metrics, startDate, endDate, frequency, relativeFiscalStart, relativeFiscalEnd, periodicity, currency);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="ids"></param>
        /// <param name="metrics"></param>
        /// <param name="startDate"></param>
        /// <param name="endDate"></param>
        /// <param name="frequency"></param>
        /// <param name="relativeFiscalStart"></param>
        /// <param name="relativeFiscalEnd"></param>
        /// <param name="periodicity"></param>
        /// <param name="currency"></param>
        partial void OnErrorGetRollingConsensus(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, List<string> ids, List<string> metrics, Option<DateOnly> startDate, Option<DateOnly> endDate, Option<string> frequency, Option<int> relativeFiscalStart, Option<int> relativeFiscalEnd, Option<string> periodicity, Option<string> currency);

        /// <summary>
        /// Retrieves consensus estimates for a requested list of ids and rolling fiscal periods. Returns FactSet Estimates consensus data using rolling fiscal dates. &lt;p&gt;The rolling behavior causes fiscal year to automatically roll from one year to the next as the historical perspective date changes. The fiscal period rolls forward as of each period end. This endpoint is optimized to allow the request to simply include a relative fiscal period (e.g. use relativeFiscalStart integer 1 and periodicity ANN for next unreported fiscal year end), and then see what the consensus thought the \&quot;next fiscal year\&quot; estimates were through time as you \&quot;roll\&quot; back your perspective dates. This differs from locking down an absolute estimate period such as explicitly stating Fiscal Year 2019. This can be done in the fixed-consensus endpoint.&lt;/p&gt; 
        /// </summary>
        /// <param name="ids">Security or Entity identifiers. Accepted inputs include FactSet Identifiers, tickers, CUSIP, and SEDOL. &lt;p&gt;&lt;b&gt;Performance Note:&lt;/b&gt; Requests that increase the number of metrics or request long historical data may trigger the 30-second service timeout threshold. To ensure system stability and performance, please keep requests lightweight.&lt;/p&gt; &lt;p&gt;If requesting long historical data, limit the history to &lt;b&gt;10 years per metric per ID&lt;/b&gt;.&lt;/p&gt; </param>
        /// <param name="metrics">Requested metrics. Use the &#x60;/metrics&#x60; endpoint to return a list of available estimate items. **Top 10** most used metrics are **EPS, SALES, DPS, EBITDA,EBIT, PRICE_TGT, CFPS, BPS, NET_INC, and ASSETS**.  For more details, visit [Online Assistant Page #15034](https://oa.apps.factset.com/pages/15034). </param>
        /// <param name="startDate">Start date for point in time of estimates expressed in YYYY-MM-DD format. (optional)</param>
        /// <param name="endDate">End date for point in time of estimates expressed in YYYY-MM-DD format. (optional)</param>
        /// <param name="frequency">Controls the frequency of the data returned.   * **D** &#x3D; Daily   * **W** &#x3D; Weekly, based on the last day of the week of the start date.   * **AM** &#x3D; Monthly, based on the start date (e.g., if the start date is June 16, data is displayed for June 16, May 16, April 16 etc.).         * **AQ** &#x3D; Quarterly, based on the start date.   * **AY** &#x3D; Actual Annual, based on the start date.   (optional, default to AM)</param>
        /// <param name="relativeFiscalStart">Relative fiscal period, expressed as an integer, used to filter results. This is combined with the periodicity parameter to specify a relative estimate period. For example, set to 1 and periodicity to ANN to ask for relative Fiscal Year 1 (FY1). (optional)</param>
        /// <param name="relativeFiscalEnd">Relative fiscal period, expressed as an integer, used to filter results. This is combined with the periodicity parameter to specify a relative estimate period. For example, set to 2 and periodicity to ANN to ask for relative Fiscal Year 1 (FY2). (optional)</param>
        /// <param name="periodicity">The periodicity for the estimates requested, allowing you to fetch Quarterly, Semi-Annual, Annual, and NTMA/LTMA Estimates.   * **ANN** - Annual   * **QTR** - Quarterly   * **SEMI** - Semi-Annual    * **NTMA** - Next-Twelve-Months - Time-weighted Annual. Estimates use a percentage of annual estimates from two fiscal years to create an estimate based on the 12-month period. Visit [OA 16614](https://my.apps.factset.com/oa/pages/16614) for detail.   * **LTMA** - Last-Twelve-Months - Time-weighted Annual. Estimates use a percentage of annual estimates from two fiscal years to create an estimate based on the 12-month period. Visit [OA 16614](https://my.apps.factset.com/oa/pages/16614) for detail.     (optional, default to ANN)</param>
        /// <param name="currency">Currency code for adjusting the data. Use &#x60;ESTIMATE&#x60; as input value for the values in Estimate Currency. For a list of currency ISO codes, visit [Online Assistant Page #1470](https://oa.apps.factset.com/pages/1470). (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetRollingConsensusApiResponse"/>&gt;</returns>
        public async Task<IGetRollingConsensusApiResponse?> GetRollingConsensusOrDefaultAsync(List<string> ids, List<string> metrics, Option<DateOnly> startDate = default, Option<DateOnly> endDate = default, Option<string> frequency = default, Option<int> relativeFiscalStart = default, Option<int> relativeFiscalEnd = default, Option<string> periodicity = default, Option<string> currency = default, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetRollingConsensusAsync(ids, metrics, startDate, endDate, frequency, relativeFiscalStart, relativeFiscalEnd, periodicity, currency, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Retrieves consensus estimates for a requested list of ids and rolling fiscal periods. Returns FactSet Estimates consensus data using rolling fiscal dates. &lt;p&gt;The rolling behavior causes fiscal year to automatically roll from one year to the next as the historical perspective date changes. The fiscal period rolls forward as of each period end. This endpoint is optimized to allow the request to simply include a relative fiscal period (e.g. use relativeFiscalStart integer 1 and periodicity ANN for next unreported fiscal year end), and then see what the consensus thought the \&quot;next fiscal year\&quot; estimates were through time as you \&quot;roll\&quot; back your perspective dates. This differs from locking down an absolute estimate period such as explicitly stating Fiscal Year 2019. This can be done in the fixed-consensus endpoint.&lt;/p&gt; 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="ids">Security or Entity identifiers. Accepted inputs include FactSet Identifiers, tickers, CUSIP, and SEDOL. &lt;p&gt;&lt;b&gt;Performance Note:&lt;/b&gt; Requests that increase the number of metrics or request long historical data may trigger the 30-second service timeout threshold. To ensure system stability and performance, please keep requests lightweight.&lt;/p&gt; &lt;p&gt;If requesting long historical data, limit the history to &lt;b&gt;10 years per metric per ID&lt;/b&gt;.&lt;/p&gt; </param>
        /// <param name="metrics">Requested metrics. Use the &#x60;/metrics&#x60; endpoint to return a list of available estimate items. **Top 10** most used metrics are **EPS, SALES, DPS, EBITDA,EBIT, PRICE_TGT, CFPS, BPS, NET_INC, and ASSETS**.  For more details, visit [Online Assistant Page #15034](https://oa.apps.factset.com/pages/15034). </param>
        /// <param name="startDate">Start date for point in time of estimates expressed in YYYY-MM-DD format. (optional)</param>
        /// <param name="endDate">End date for point in time of estimates expressed in YYYY-MM-DD format. (optional)</param>
        /// <param name="frequency">Controls the frequency of the data returned.   * **D** &#x3D; Daily   * **W** &#x3D; Weekly, based on the last day of the week of the start date.   * **AM** &#x3D; Monthly, based on the start date (e.g., if the start date is June 16, data is displayed for June 16, May 16, April 16 etc.).         * **AQ** &#x3D; Quarterly, based on the start date.   * **AY** &#x3D; Actual Annual, based on the start date.   (optional, default to AM)</param>
        /// <param name="relativeFiscalStart">Relative fiscal period, expressed as an integer, used to filter results. This is combined with the periodicity parameter to specify a relative estimate period. For example, set to 1 and periodicity to ANN to ask for relative Fiscal Year 1 (FY1). (optional)</param>
        /// <param name="relativeFiscalEnd">Relative fiscal period, expressed as an integer, used to filter results. This is combined with the periodicity parameter to specify a relative estimate period. For example, set to 2 and periodicity to ANN to ask for relative Fiscal Year 1 (FY2). (optional)</param>
        /// <param name="periodicity">The periodicity for the estimates requested, allowing you to fetch Quarterly, Semi-Annual, Annual, and NTMA/LTMA Estimates.   * **ANN** - Annual   * **QTR** - Quarterly   * **SEMI** - Semi-Annual    * **NTMA** - Next-Twelve-Months - Time-weighted Annual. Estimates use a percentage of annual estimates from two fiscal years to create an estimate based on the 12-month period. Visit [OA 16614](https://my.apps.factset.com/oa/pages/16614) for detail.   * **LTMA** - Last-Twelve-Months - Time-weighted Annual. Estimates use a percentage of annual estimates from two fiscal years to create an estimate based on the 12-month period. Visit [OA 16614](https://my.apps.factset.com/oa/pages/16614) for detail.     (optional, default to ANN)</param>
        /// <param name="currency">Currency code for adjusting the data. Use &#x60;ESTIMATE&#x60; as input value for the values in Estimate Currency. For a list of currency ISO codes, visit [Online Assistant Page #1470](https://oa.apps.factset.com/pages/1470). (optional)</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetRollingConsensusApiResponse"/>&gt;</returns>
        public async Task<IGetRollingConsensusApiResponse> GetRollingConsensusAsync(List<string> ids, List<string> metrics, Option<DateOnly> startDate = default, Option<DateOnly> endDate = default, Option<string> frequency = default, Option<int> relativeFiscalStart = default, Option<int> relativeFiscalEnd = default, Option<string> periodicity = default, Option<string> currency = default, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetRollingConsensus(ids, metrics, frequency, periodicity, currency);

                FormatGetRollingConsensus(ids, metrics, ref startDate, ref endDate, ref frequency, ref relativeFiscalStart, ref relativeFiscalEnd, ref periodicity, ref currency);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/factset-estimates/v2/rolling-consensus"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/factset-estimates/v2/rolling-consensus");

                    System.Collections.Specialized.NameValueCollection parseQueryStringLocalVar = System.Web.HttpUtility.ParseQueryString(string.Empty);

                    parseQueryStringLocalVar["ids"] = ClientUtils.ParameterToString(ids);
                    parseQueryStringLocalVar["metrics"] = ClientUtils.ParameterToString(metrics);

                    if (startDate.IsSet)
                        parseQueryStringLocalVar["startDate"] = ClientUtils.ParameterToString(startDate.Value);

                    if (endDate.IsSet)
                        parseQueryStringLocalVar["endDate"] = ClientUtils.ParameterToString(endDate.Value);

                    if (frequency.IsSet)
                        parseQueryStringLocalVar["frequency"] = ClientUtils.ParameterToString(frequency.Value);

                    if (relativeFiscalStart.IsSet)
                        parseQueryStringLocalVar["relativeFiscalStart"] = ClientUtils.ParameterToString(relativeFiscalStart.Value);

                    if (relativeFiscalEnd.IsSet)
                        parseQueryStringLocalVar["relativeFiscalEnd"] = ClientUtils.ParameterToString(relativeFiscalEnd.Value);

                    if (periodicity.IsSet)
                        parseQueryStringLocalVar["periodicity"] = ClientUtils.ParameterToString(periodicity.Value);

                    if (currency.IsSet)
                        parseQueryStringLocalVar["currency"] = ClientUtils.ParameterToString(currency.Value);

                    uriBuilderLocalVar.Query = parseQueryStringLocalVar.ToString();

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BasicToken basicTokenLocalVar1 = (BasicToken) await BasicTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(basicTokenLocalVar1);

                    basicTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Get;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetRollingConsensusApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetRollingConsensusApiResponse>();
                        GetRollingConsensusApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/factset-estimates/v2/rolling-consensus", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetRollingConsensusDefaultImplementation(apiResponseLocalVar, ids, metrics, startDate, endDate, frequency, relativeFiscalStart, relativeFiscalEnd, periodicity, currency);

                        Events.ExecuteOnGetRollingConsensus(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetRollingConsensusDefaultImplementation(e, "/factset-estimates/v2/rolling-consensus", uriBuilderLocalVar.Path, ids, metrics, startDate, endDate, frequency, relativeFiscalStart, relativeFiscalEnd, periodicity, currency);
                Events.ExecuteOnErrorGetRollingConsensus(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetRollingConsensusApiResponse"/>
        /// </summary>
        public partial class GetRollingConsensusApiResponse : FactsetEstimatesClient.Client.ApiResponse, IGetRollingConsensusApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetRollingConsensusApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetRollingConsensusApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetRollingConsensusApiResponse(ILogger<GetRollingConsensusApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetRollingConsensusApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetRollingConsensusApiResponse(ILogger<GetRollingConsensusApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public FactsetEstimatesClient.Model.ConsensusResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<FactsetEstimatesClient.Model.ConsensusResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out FactsetEstimatesClient.Model.ConsensusResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public FactsetEstimatesClient.Model.ErrorResponse? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<FactsetEstimatesClient.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out FactsetEstimatesClient.Model.ErrorResponse? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public FactsetEstimatesClient.Model.ErrorResponse? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<FactsetEstimatesClient.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out FactsetEstimatesClient.Model.ErrorResponse? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public FactsetEstimatesClient.Model.ErrorResponse? Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<FactsetEstimatesClient.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out FactsetEstimatesClient.Model.ErrorResponse? result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 415 UnsupportedMediaType
            /// </summary>
            /// <returns></returns>
            public bool IsUnsupportedMediaType => 415 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 415 UnsupportedMediaType
            /// </summary>
            /// <returns></returns>
            public FactsetEstimatesClient.Model.ErrorResponse? UnsupportedMediaType()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnsupportedMediaType
                    ? System.Text.Json.JsonSerializer.Deserialize<FactsetEstimatesClient.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 415 UnsupportedMediaType and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnsupportedMediaType([NotNullWhen(true)]out FactsetEstimatesClient.Model.ErrorResponse? result)
            {
                result = null;

                try
                {
                    result = UnsupportedMediaType();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)415);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public FactsetEstimatesClient.Model.ErrorResponse? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<FactsetEstimatesClient.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out FactsetEstimatesClient.Model.ErrorResponse? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }

        partial void FormatGetRollingConsensusForList(RollingConsensusRequest rollingConsensusRequest);

        /// <summary>
        /// Validates the request parameters
        /// </summary>
        /// <param name="rollingConsensusRequest"></param>
        /// <returns></returns>
        private void ValidateGetRollingConsensusForList(RollingConsensusRequest rollingConsensusRequest)
        {
            if (rollingConsensusRequest == null)
                throw new ArgumentNullException(nameof(rollingConsensusRequest));
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="rollingConsensusRequest"></param>
        private void AfterGetRollingConsensusForListDefaultImplementation(IGetRollingConsensusForListApiResponse apiResponseLocalVar, RollingConsensusRequest rollingConsensusRequest)
        {
            bool suppressDefaultLog = false;
            AfterGetRollingConsensusForList(ref suppressDefaultLog, apiResponseLocalVar, rollingConsensusRequest);
            if (!suppressDefaultLog)
                Logger.LogInformation("{0,-9} | {1} | {3}", (apiResponseLocalVar.DownloadedAt - apiResponseLocalVar.RequestedAt).TotalSeconds, apiResponseLocalVar.StatusCode, apiResponseLocalVar.Path);
        }

        /// <summary>
        /// Processes the server response
        /// </summary>
        /// <param name="suppressDefaultLog"></param>
        /// <param name="apiResponseLocalVar"></param>
        /// <param name="rollingConsensusRequest"></param>
        partial void AfterGetRollingConsensusForList(ref bool suppressDefaultLog, IGetRollingConsensusForListApiResponse apiResponseLocalVar, RollingConsensusRequest rollingConsensusRequest);

        /// <summary>
        /// Logs exceptions that occur while retrieving the server response
        /// </summary>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="rollingConsensusRequest"></param>
        private void OnErrorGetRollingConsensusForListDefaultImplementation(Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, RollingConsensusRequest rollingConsensusRequest)
        {
            bool suppressDefaultLogLocalVar = false;
            OnErrorGetRollingConsensusForList(ref suppressDefaultLogLocalVar, exceptionLocalVar, pathFormatLocalVar, pathLocalVar, rollingConsensusRequest);
            if (!suppressDefaultLogLocalVar)
                Logger.LogError(exceptionLocalVar, "An error occurred while sending the request to the server.");
        }

        /// <summary>
        /// A partial method that gives developers a way to provide customized exception handling
        /// </summary>
        /// <param name="suppressDefaultLogLocalVar"></param>
        /// <param name="exceptionLocalVar"></param>
        /// <param name="pathFormatLocalVar"></param>
        /// <param name="pathLocalVar"></param>
        /// <param name="rollingConsensusRequest"></param>
        partial void OnErrorGetRollingConsensusForList(ref bool suppressDefaultLogLocalVar, Exception exceptionLocalVar, string pathFormatLocalVar, string pathLocalVar, RollingConsensusRequest rollingConsensusRequest);

        /// <summary>
        /// Retrieves consensus estimates for a requested list of ids and rolling fiscal periods Returns FactSet Estimates consensus data using rolling fiscal dates. &lt;p&gt;The rolling behavior causes fiscal year to automatically roll from one year to the next as the historical perspective date changes. The fiscal period rolls forward as of each period end. This endpoint is optimized to allow the request to simply include a relative fiscal period (e.g. use relativeFiscalStart integer 1 and periodicity ANN for next unreported fiscal year end), and then see what the consensus thought the \&quot;next fiscal year\&quot; estimates were through time as you \&quot;roll\&quot; back your perspective dates. This differs from locking down an absolute estimate period such as explicitly stating Fiscal Year 2019. This can be done in the fixed-consensus endpoint.&lt;/p&gt; 
        /// </summary>
        /// <param name="rollingConsensusRequest">Request object for Rolling Conensus estimates.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetRollingConsensusForListApiResponse"/>&gt;</returns>
        public async Task<IGetRollingConsensusForListApiResponse?> GetRollingConsensusForListOrDefaultAsync(RollingConsensusRequest rollingConsensusRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            try
            {
                return await GetRollingConsensusForListAsync(rollingConsensusRequest, cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
                return null;
            }
        }

        /// <summary>
        /// Retrieves consensus estimates for a requested list of ids and rolling fiscal periods Returns FactSet Estimates consensus data using rolling fiscal dates. &lt;p&gt;The rolling behavior causes fiscal year to automatically roll from one year to the next as the historical perspective date changes. The fiscal period rolls forward as of each period end. This endpoint is optimized to allow the request to simply include a relative fiscal period (e.g. use relativeFiscalStart integer 1 and periodicity ANN for next unreported fiscal year end), and then see what the consensus thought the \&quot;next fiscal year\&quot; estimates were through time as you \&quot;roll\&quot; back your perspective dates. This differs from locking down an absolute estimate period such as explicitly stating Fiscal Year 2019. This can be done in the fixed-consensus endpoint.&lt;/p&gt; 
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        /// <param name="rollingConsensusRequest">Request object for Rolling Conensus estimates.</param>
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="IGetRollingConsensusForListApiResponse"/>&gt;</returns>
        public async Task<IGetRollingConsensusForListApiResponse> GetRollingConsensusForListAsync(RollingConsensusRequest rollingConsensusRequest, System.Threading.CancellationToken cancellationToken = default)
        {
            UriBuilder uriBuilderLocalVar = new UriBuilder();

            try
            {
                ValidateGetRollingConsensusForList(rollingConsensusRequest);

                FormatGetRollingConsensusForList(rollingConsensusRequest);

                using (HttpRequestMessage httpRequestMessageLocalVar = new HttpRequestMessage())
                {
                    uriBuilderLocalVar.Host = HttpClient.BaseAddress!.Host;
                    uriBuilderLocalVar.Port = HttpClient.BaseAddress.Port;
                    uriBuilderLocalVar.Scheme = HttpClient.BaseAddress.Scheme;
                    uriBuilderLocalVar.Path = HttpClient.BaseAddress.AbsolutePath == "/"
                        ? "/factset-estimates/v2/rolling-consensus"
                        : string.Concat(HttpClient.BaseAddress.AbsolutePath, "/factset-estimates/v2/rolling-consensus");

                    httpRequestMessageLocalVar.Content = (rollingConsensusRequest as object) is System.IO.Stream stream
                        ? httpRequestMessageLocalVar.Content = new StreamContent(stream)
                        : httpRequestMessageLocalVar.Content = new StringContent(JsonSerializer.Serialize(rollingConsensusRequest, _jsonSerializerOptions));

                    List<TokenBase> tokenBaseLocalVars = new List<TokenBase>();
                    httpRequestMessageLocalVar.RequestUri = uriBuilderLocalVar.Uri;

                    BasicToken basicTokenLocalVar1 = (BasicToken) await BasicTokenProvider.GetAsync(cancellation: cancellationToken).ConfigureAwait(false);

                    tokenBaseLocalVars.Add(basicTokenLocalVar1);

                    basicTokenLocalVar1.UseInHeader(httpRequestMessageLocalVar, "");

                    string[] contentTypes = new string[] {
                        "application/json"
                    };

                    string? contentTypeLocalVar = ClientUtils.SelectHeaderContentType(contentTypes);

                    if (contentTypeLocalVar != null && httpRequestMessageLocalVar.Content != null)
                        httpRequestMessageLocalVar.Content.Headers.ContentType = new MediaTypeHeaderValue(contentTypeLocalVar);

                    string[] acceptLocalVars = new string[] {
                        "application/json"
                    };

                    string? acceptLocalVar = ClientUtils.SelectHeaderAccept(acceptLocalVars);

                    if (acceptLocalVar != null)
                        httpRequestMessageLocalVar.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(acceptLocalVar));

                    httpRequestMessageLocalVar.Method = HttpMethod.Post;

                    DateTime requestedAtLocalVar = DateTime.UtcNow;

                    using (HttpResponseMessage httpResponseMessageLocalVar = await HttpClient.SendAsync(httpRequestMessageLocalVar, cancellationToken).ConfigureAwait(false))
                    {
                        ILogger<GetRollingConsensusForListApiResponse> apiResponseLoggerLocalVar = LoggerFactory.CreateLogger<GetRollingConsensusForListApiResponse>();
                        GetRollingConsensusForListApiResponse apiResponseLocalVar;

                        switch ((int)httpResponseMessageLocalVar.StatusCode) {
                            default: {
                                string responseContentLocalVar = await httpResponseMessageLocalVar.Content.ReadAsStringAsync(cancellationToken).ConfigureAwait(false);
                                apiResponseLocalVar = new(apiResponseLoggerLocalVar, httpRequestMessageLocalVar, httpResponseMessageLocalVar, responseContentLocalVar, "/factset-estimates/v2/rolling-consensus", requestedAtLocalVar, _jsonSerializerOptions);

                                break;
                            }
                        }

                        AfterGetRollingConsensusForListDefaultImplementation(apiResponseLocalVar, rollingConsensusRequest);

                        Events.ExecuteOnGetRollingConsensusForList(apiResponseLocalVar);

                        if (apiResponseLocalVar.StatusCode == (HttpStatusCode) 429)
                            foreach(TokenBase tokenBaseLocalVar in tokenBaseLocalVars)
                                tokenBaseLocalVar.BeginRateLimit();

                        return apiResponseLocalVar;
                    }
                }
            }
            catch(Exception e)
            {
                OnErrorGetRollingConsensusForListDefaultImplementation(e, "/factset-estimates/v2/rolling-consensus", uriBuilderLocalVar.Path, rollingConsensusRequest);
                Events.ExecuteOnErrorGetRollingConsensusForList(e);
                throw;
            }
        }

        /// <summary>
        /// The <see cref="GetRollingConsensusForListApiResponse"/>
        /// </summary>
        public partial class GetRollingConsensusForListApiResponse : FactsetEstimatesClient.Client.ApiResponse, IGetRollingConsensusForListApiResponse
        {
            /// <summary>
            /// The logger
            /// </summary>
            public ILogger<GetRollingConsensusForListApiResponse> Logger { get; }

            /// <summary>
            /// The <see cref="GetRollingConsensusForListApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="rawContent"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetRollingConsensusForListApiResponse(ILogger<GetRollingConsensusForListApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, string rawContent, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, rawContent, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            /// <summary>
            /// The <see cref="GetRollingConsensusForListApiResponse"/>
            /// </summary>
            /// <param name="logger"></param>
            /// <param name="httpRequestMessage"></param>
            /// <param name="httpResponseMessage"></param>
            /// <param name="contentStream"></param>
            /// <param name="path"></param>
            /// <param name="requestedAt"></param>
            /// <param name="jsonSerializerOptions"></param>
            public GetRollingConsensusForListApiResponse(ILogger<GetRollingConsensusForListApiResponse> logger, System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage, System.IO.Stream contentStream, string path, DateTime requestedAt, System.Text.Json.JsonSerializerOptions jsonSerializerOptions) : base(httpRequestMessage, httpResponseMessage, contentStream, path, requestedAt, jsonSerializerOptions)
            {
                Logger = logger;
                OnCreated(httpRequestMessage, httpResponseMessage);
            }

            partial void OnCreated(global::System.Net.Http.HttpRequestMessage httpRequestMessage, System.Net.Http.HttpResponseMessage httpResponseMessage);

            /// <summary>
            /// Returns true if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public bool IsOk => 200 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 200 Ok
            /// </summary>
            /// <returns></returns>
            public FactsetEstimatesClient.Model.ConsensusResponse? Ok()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsOk
                    ? System.Text.Json.JsonSerializer.Deserialize<FactsetEstimatesClient.Model.ConsensusResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 200 Ok and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryOk([NotNullWhen(true)]out FactsetEstimatesClient.Model.ConsensusResponse? result)
            {
                result = null;

                try
                {
                    result = Ok();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)200);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public bool IsBadRequest => 400 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 400 BadRequest
            /// </summary>
            /// <returns></returns>
            public FactsetEstimatesClient.Model.ErrorResponse? BadRequest()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsBadRequest
                    ? System.Text.Json.JsonSerializer.Deserialize<FactsetEstimatesClient.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 400 BadRequest and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryBadRequest([NotNullWhen(true)]out FactsetEstimatesClient.Model.ErrorResponse? result)
            {
                result = null;

                try
                {
                    result = BadRequest();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)400);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public bool IsUnauthorized => 401 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 401 Unauthorized
            /// </summary>
            /// <returns></returns>
            public FactsetEstimatesClient.Model.ErrorResponse? Unauthorized()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnauthorized
                    ? System.Text.Json.JsonSerializer.Deserialize<FactsetEstimatesClient.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 401 Unauthorized and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnauthorized([NotNullWhen(true)]out FactsetEstimatesClient.Model.ErrorResponse? result)
            {
                result = null;

                try
                {
                    result = Unauthorized();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)401);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public bool IsForbidden => 403 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 403 Forbidden
            /// </summary>
            /// <returns></returns>
            public FactsetEstimatesClient.Model.ErrorResponse? Forbidden()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsForbidden
                    ? System.Text.Json.JsonSerializer.Deserialize<FactsetEstimatesClient.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 403 Forbidden and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryForbidden([NotNullWhen(true)]out FactsetEstimatesClient.Model.ErrorResponse? result)
            {
                result = null;

                try
                {
                    result = Forbidden();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)403);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 415 UnsupportedMediaType
            /// </summary>
            /// <returns></returns>
            public bool IsUnsupportedMediaType => 415 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 415 UnsupportedMediaType
            /// </summary>
            /// <returns></returns>
            public FactsetEstimatesClient.Model.ErrorResponse? UnsupportedMediaType()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsUnsupportedMediaType
                    ? System.Text.Json.JsonSerializer.Deserialize<FactsetEstimatesClient.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 415 UnsupportedMediaType and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryUnsupportedMediaType([NotNullWhen(true)]out FactsetEstimatesClient.Model.ErrorResponse? result)
            {
                result = null;

                try
                {
                    result = UnsupportedMediaType();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)415);
                }

                return result != null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public bool IsInternalServerError => 500 == (int)StatusCode;

            /// <summary>
            /// Deserializes the response if the response is 500 InternalServerError
            /// </summary>
            /// <returns></returns>
            public FactsetEstimatesClient.Model.ErrorResponse? InternalServerError()
            {
                // This logic may be modified with the AsModel.mustache template
                return IsInternalServerError
                    ? System.Text.Json.JsonSerializer.Deserialize<FactsetEstimatesClient.Model.ErrorResponse>(RawContent, _jsonSerializerOptions)
                    : null;
            }

            /// <summary>
            /// Returns true if the response is 500 InternalServerError and the deserialized response is not null
            /// </summary>
            /// <param name="result"></param>
            /// <returns></returns>
            public bool TryInternalServerError([NotNullWhen(true)]out FactsetEstimatesClient.Model.ErrorResponse? result)
            {
                result = null;

                try
                {
                    result = InternalServerError();
                } catch (Exception e)
                {
                    OnDeserializationErrorDefaultImplementation(e, (HttpStatusCode)500);
                }

                return result != null;
            }

            private void OnDeserializationErrorDefaultImplementation(Exception exception, HttpStatusCode httpStatusCode)
            {
                bool suppressDefaultLog = false;
                OnDeserializationError(ref suppressDefaultLog, exception, httpStatusCode);
                if (!suppressDefaultLog)
                    Logger.LogError(exception, "An error occurred while deserializing the {code} response.", httpStatusCode);
            }

            partial void OnDeserializationError(ref bool suppressDefaultLog, Exception exception, HttpStatusCode httpStatusCode);
        }
    }
}
